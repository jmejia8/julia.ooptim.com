<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/jtd.css"> <link rel=icon  href="/assets/favicon.ico"> <title>Working with Threads: A simple application</title> <div class=page-wrap > <div class=side-bar > <div class=header > <a href="/" class=title > Posts on JuliaLang </a> </div> <label for=show-menu  class=show-menu >MENU</label> <input type=checkbox  id=show-menu  role=button > <div class=menu  id=side-menu > <ul class=menu-list > <li class="menu-list-item "><a href="/" class="menu-list-link ">Home</a> <!-- <li class="menu-list-item {{ispage menu3/*}}active{{end}}"><a href="/menu3/" class="menu-list-link {{ispage menu3}}active{{end}}">Tags</a> <ul class="menu-list-child-list "> <li class="menu-list-item "><a href="#" class=menu-list-link >Submenu</a> </ul> --> <li class="menu-list-item "><a href="/posts/threads" class="menu-list-link ">Working with threads</a> </ul> </div> <div class=footer > Learn more here. </div> </div> <div class=main-content-wrap > <div class=main-content > <div class=main-header > <a id=github  href="//github.com/jmejia8">Edit me on GitHub</a> </div> <div class=franklin-content > <h1 id=working_with_threads_a_simple_application ><a href="#working_with_threads_a_simple_application" class=header-anchor >Working with Threads: A simple application</a></h1> <div class=franklin-toc ><ol><li><a href="#using_multiple_threads">Using Multiple Threads</a><ol><li><a href="#initialize_julia">Initialize Julia</a><li><a href="#code_the_expensive_task">Code the expensive task</a><li><a href="#saving_the_data">Saving the data</a><li><a href="#run_the_experiments">Run the experiments</a></ol><li><a href="#threads_and_mutex">Threads and Mutex</a><ol><li><a href="#implementing_mutex">Implementing Mutex</a></ol></ol></div> <p>Running multiple tasks simultaneously becomes convenient when you have powerful computer able to launch at least four threads. This post will remember out to implement <strong>mutex</strong> tasks because I wanted to plot stuff in different threads but I obtained a <strong>segmentation fault</strong> due to <code>Plots</code> &#40;on <code>GR</code> backend&#41; cannot plot two or more figures at the same time in different threads.</p> <h2 id=using_multiple_threads ><a href="#using_multiple_threads" class=header-anchor >Using Multiple Threads</a></h2> <p>Let&#39;s run multiple tasks in different threads. </p> <h3 id=initialize_julia ><a href="#initialize_julia" class=header-anchor >Initialize Julia</a></h3> <p>Start Julia indicating the number of threads available &#40;<strong>4</strong> in my case&#41; for the simulations:</p> <pre><code class="shell hljs"><span class=hljs-meta >$ </span><span class=language-bash >julia --threads 4</span></code></pre>
<h3 id=code_the_expensive_task ><a href="#code_the_expensive_task" class=header-anchor >Code the expensive task</a></h3>
<p>Here, <code>my_expensive_task</code> implements a very expensive task that will run a thread.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> my_expensive_task(μ, σ, n)
    sleep(<span class=hljs-number >3</span>)
    <span class=hljs-keyword >return</span> μ .+ σ^<span class=hljs-number >2</span> * randn(n, n)
<span class=hljs-keyword >end</span></code></pre>
<h3 id=saving_the_data ><a href="#saving_the_data" class=header-anchor >Saving the data</a></h3>
<p>This function will save the data obtained from <code>my_expensive_task</code>.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> save_data(data, i)
    sleep(<span class=hljs-number >1</span>)
    <span class=hljs-meta >@show</span> i
    display(data)
    <span class=hljs-keyword >return</span> <span class=hljs-literal >true</span>
<span class=hljs-keyword >end</span></code></pre>
<h3 id=run_the_experiments ><a href="#run_the_experiments" class=header-anchor >Run the experiments</a></h3>
<p>The <code>main</code> function will run <code>my_expensive_task</code> in 4 threads and save the obtained data.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> main()
    n_experiments = <span class=hljs-number >16</span>
    n = <span class=hljs-number >5</span>
    Threads.<span class=hljs-meta >@threads</span> <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:n_experiments
        μ = rand()
        σ = rand()
        M = my_expensive_task(μ, σ, n)
        save_data(M, i)
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span></code></pre>
<h2 id=threads_and_mutex ><a href="#threads_and_mutex" class=header-anchor >Threads and Mutex</a></h2>
<p>Here, <a href="https://rosettacode.org/wiki/Mutex#:~:text&#61;Mutexes&#37;20are&#37;20typically&#37;20used&#37;20to,synchronization&#37;20primitive&#37;20exposed&#37;20to&#37;20deadlocking.">Mutex</a> are used to execute tasks only once via synchronization.</p>
<p>In Julia there exists a useful synchronization object called <code>ReentrantLock&#40;&#41;</code> to lock let only one execution of the desired task. The implementation of a mutex in Julia is very simple.</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=language-julia >?<span class=hljs-built_in >ReentrantLock</span>()
</span>
  ReentrantLock()

  Creates a re-entrant lock for synchronizing Tasks. The same task can acquire the lock as many times as required.
  Each lock must be matched with an unlock.

  Calling &#x27;lock&#x27; will also inhibit running of finalizers on that thread until the corresponding &#x27;unlock&#x27;. Use of the
  standard lock pattern illustrated below should naturally be supported, but beware of inverting the try/lock order
  or missing the try block entirely (e.g. attempting to return with the lock still held):

  lock(l)
  try
      &lt;atomic work&gt;
  finally
      unlock(l)
  end</code></pre>
<h3 id=implementing_mutex ><a href="#implementing_mutex" class=header-anchor >Implementing Mutex</a></h3>
<p>Assume that you only can save data once at a time. To prevent that different threads call <code>save_data</code> at the same time, let&#39;s <code>lock</code> that action. Return to the <code>main</code> function and add the following lines to implement the mutex.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> main()
    n_experiments = <span class=hljs-number >16</span>

    <span class=hljs-comment ># data size</span>
    n = <span class=hljs-number >5</span> 
    mutex = <span class=hljs-built_in >ReentrantLock</span>() <span class=hljs-comment ># used to save data</span>

    Threads.<span class=hljs-meta >@threads</span> <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:n_experiments
        μ = rand()
        σ = rand()

        <span class=hljs-comment ># do simulations</span>
        M = my_expensive_task(μ, σ, n)

        <span class=hljs-comment ># using mutex while saving data</span>
        lock(() -&gt; save_data(M, i), mutex)
        
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span></code></pre>
<p><strong>Note</strong> that you don not need to unlock the mutex due to <code>lock</code> does it automatically when <code>save_data</code> returns a value.</p>
<div class=page-foot >
  <div class=copyright >
    &copy; Jesús Mejía. Last modified: February 02, 2022. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
    </div> 
    </div> 
    </div> <!-- end of class page-wrap-->